<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leverTsui</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.leverTsui.com/"/>
  <updated>2017-11-06T11:27:11.000Z</updated>
  <id>http://www.leverTsui.com/</id>
  
  <author>
    <name>leverTsui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS布局与Masnory使用实践</title>
    <link href="http://www.leverTsui.com/2017/11/06/iOS%E5%B8%83%E5%B1%80%E4%B8%8EMasnory%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.leverTsui.com/2017/11/06/iOS布局与Masnory使用实践/</id>
    <published>2017-11-06T10:46:28.000Z</published>
    <updated>2017-11-06T11:27:11.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p><code>UI</code>布局对于<code>iOS</code>开发者来说并不陌生，在<code>iOS6</code>之前，大家都是通过<code>UI</code>控件的<code>Frame</code>属性和<code>Autoresizing Mask</code>来进行<code>UI</code>布局的（简称为手动布局）。<code>AutoLayout</code>则是苹果公司在<code>iOS6</code>推出的一种基于约束的，描述性的布局系统（简称为自动布局），这里主要从四个方面来阐述iOS布局及实践。</p><ul><li>手动布局和自动布局</li><li><code>AutoLayout</code>原理</li><li><code>AutoLayout</code>的性能</li><li><code>Masnory</code>的使用</li></ul><p>首先对手动布局和自动布局做一个简单的介绍：</p><h5 id="手动布局和自动布局"><a href="#手动布局和自动布局" class="headerlink" title="手动布局和自动布局"></a>手动布局和自动布局</h5><ul><li><p>手动布局：指的是通过直接修改视图的<code>frame</code>属性的方式对界面进行布局。 </p><blockquote><p>对于<code>IOS</code>的<code>app</code>开发者来说，不会像<code>Android</code>开发者一样为很多的屏幕尺寸来做界面适配，因此手动调整 <code>frame</code>的方式来布局也能工作良好。但是还是会有一些问题，如设备发生旋转、适配<code>ipad</code>等，并且保证视图原来之间的相对关系，则以上的方法都是无法解决的。如果要做这些适配，在<code>AutoLayout</code>未出来之前需要编写大量的代码，并且花费大量的调试适配时间。 </p></blockquote></li><li><p>自动布局：指的是使用<code>AutoLayout</code>的方式对界面进行布局。</p></li></ul><blockquote><p><code>AutoLayout</code> 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 <code>AutoLayout</code>对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，<code>AutoLayout</code> 带来的 <code>CPU</code> 消耗会呈指数级上升。 如果对界面流畅度要求较高（如微博界面），可以通过提前计算好布局，在需要时一次性调整好对应属性 ，或者使用 <code>ComponentKit</code>、<code>AsyncDisplayKit</code> 等框架来处理界面布局。</p></blockquote><p>下面，我们来分析下 AutoLayout的原理。</p><h5 id="AutoLayout的原理"><a href="#AutoLayout的原理" class="headerlink" title="AutoLayout的原理"></a>AutoLayout的原理</h5><p>这里通过使用<code>Masonry</code>来进行布局，从而来分析<code>AutoLayout</code>的原理，先简要了解下<code>Masonry</code>。<br><code>Masonry</code>是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了，并具有高可读性，而且同时支持 <code>iOS</code> 和 <code>Max OS X</code>。<br><code>Masnory</code>支持的常用属性如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *left;     <span class="comment">//左侧</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *top;      <span class="comment">//上侧</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *right;   <span class="comment">//右侧</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottom;   <span class="comment">//下侧</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leading;  <span class="comment">//首部</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *trailing;  <span class="comment">//首部</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *width;    <span class="comment">//宽</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *height;   <span class="comment">//高</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerX;  <span class="comment">//横向中点</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerY;  <span class="comment">//纵向中点</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *baseline; <span class="comment">//文本基线</span></div></pre></td></tr></table></figure></p><p><strong>其中<code>leading</code>与<code>left</code>，<code>trailing</code>与<code>right</code> 在正常情况下是等价的，但是当一些布局是从右至左时(比如阿拉伯语) 则会对调。</strong><br>同时，在<code>Masonry</code>中能够添加<code>AutoLayout</code>约束有三个函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block;<span class="comment">//只负责新增约束` AutoLayout`不能同时存在两条针对于同一对象的约束,否则会报错</span></div><div class="line">- (<span class="built_in">NSArray</span> *)mas_updateConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block;<span class="comment">//针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</span></div><div class="line">- (<span class="built_in">NSArray</span> *)mas_remakeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block;<span class="comment">//则会清除之前的所有约束 仅保留最新的约束</span></div></pre></td></tr></table></figure></p><p>我们在代码中，经常会使用到<code>equalTo</code>和<code>mas_equalTo</code>，那它们的区别是什么呢？从代码中找到他们的定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define mas_equalTo(...)                 equalTo(MASBoxValue((__VA_ARGS__)))</span></div><div class="line">...</div><div class="line"><span class="meta">#define MASBoxValue(value) _MASBoxValue(@encode(__typeof__((value))), (value))</span></div></pre></td></tr></table></figure></p><p>可以看到 <code>mas_equalTo</code>只是对其参数进行了一个<code>BOX</code>操作(装箱) ，所支持的类型，除了<code>NSNumber</code>支持的那些数值类型之外，还支持<code>CGPoint</code>，<code>CGSize</code>和<code>UIEdgeInsets</code>类型。<br>下面，我们通过一个例子，一步步来看下界面是怎么布局的，代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">    </div><div class="line">    <span class="built_in">UIView</span> *v1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">    v1.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">    [v1 showPlaceHolder];</div><div class="line">    </div><div class="line">    <span class="built_in">UIView</span> *v2 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">    v2.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">    [v2 showPlaceHolder];</div><div class="line">    </div><div class="line">    <span class="built_in">UIView</span> *v3 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">    v3.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">    [v3 showPlaceHolder];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.view addSubview:v1];</div><div class="line">    [<span class="keyword">self</span>.view addSubview:v2];</div><div class="line">    [<span class="keyword">self</span>.view addSubview:v3];</div><div class="line">    </div><div class="line">    [v1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.top.mas_equalTo(<span class="number">100</span>);</div><div class="line">        make.leading.mas_equalTo(<span class="number">100</span>);</div><div class="line">        make.width.mas_equalTo(<span class="number">70</span>);</div><div class="line">        make.height.mas_equalTo(<span class="number">65</span>);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [v2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.top.equalTo(v1.mas_top);</div><div class="line">        make.leading.mas_equalTo(v1.mas_trailing).offset(<span class="number">20</span>);</div><div class="line">        make.width.equalTo(v1.mas_width);</div><div class="line">        make.height.equalTo(v1.mas_height);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [v3 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.top.equalTo(v1.mas_bottom).offset(<span class="number">20</span>);</div><div class="line">        make.leading.equalTo(v1.mas_leading);</div><div class="line">        make.trailing.equalTo(v2.mas_trailing);</div><div class="line">        make.height.equalTo(v1.mas_height);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>界面运行结果如下图：<br><img src="http://upload-images.jianshu.io/upload_images/5835116-10acd4fa0c0e292c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CD52E302-FAFD-4D6E-9DFF-F5DB44C6098B.png"><br>下面，我们将界面中的左上角的视图视为视图1，右上角的视图视为视图2，底部视图视为视图3，使用<code>x1、y1、m1、n1</code>来标识视图1的<code>left</code>、<code>top</code>、<code>width</code>和<code>height</code>，以此类推。<br>通过以上举例抽象出自动布局数学公式：<br> <img src="http://upload-images.jianshu.io/upload_images/5835116-6ceec51e08a7f571.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1C7344E7-1ED1-421A-B84E-ACBD70F98859.png"><br>将以上等式变形为：</p><p><img src="http://upload-images.jianshu.io/upload_images/5835116-101854d5027207fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8AAD54BE-0157-4591-A117-0094F69BE6E7.png"><br>此时，以上方程组，大家肯定很熟悉了，也就是《线性代数》中的线性方程组，现在将以上线性方程组抽象为：</p><p><img src="http://upload-images.jianshu.io/upload_images/5835116-665ec9939aa6a902.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="B5E84F57-07DE-4A15-9D06-3D0ADD7E6EBD.png"><br>上图表示“等式”方程组，那么是否还可以继续抽象？也就是说上述方程组能否完全表示未知元素之间与已知元素之间的关系，显然还不全面，因为还有（&lt;,&gt;,&lt;=,&gt;=）不等关系，因此将“=”等号抽象为关系”R”,在数学上关系R也就包括了“=”,”&lt;”,”&gt;”,”&lt;=”,”&gt;=”等关系。上述线程方程组变形为：（实质上，AutoLayout中所有的约束确实都是用数学关系式y R ax + b描述）</p><p><img src="http://upload-images.jianshu.io/upload_images/5835116-8ae25f0ead6f4c29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9A877277-5DEB-437C-AEF6-D6530AB6FE6F.png"><br>现在已经将自动布局一步步抽象为数学公式，那么对视图的布局其实就是对线性方程组的求解。线性方程组解的情况有三种，实质上也对应着自动布局对视图的三种布局方案:</p><ul><li>唯一解：所有方程中的未知数能够解出唯一解。 充分约束：给一个视图添加的约束必须是充分的，才能正确布局一个视图；</li><li>多个解：未知数不能求解出准确的唯一解，即未知数可能存在多个或者无限个解满足线性方程组。 欠约束：给视图所添加的约束不能够充分的表达视图的准确位置，在这种情况下自动布局会随意给视图一个布局方案，也就是自动布局中视图不能够正确布局或者视图丢失的情况。 </li><li>无解：不存在满足线性方程组的解。 冲突约束：给视图添加的约束表达视图布局出现了冲突，比如同时满足同一个视图宽度即为100又为200，这是不可能存在的。此时程序会出现崩溃。</li></ul><p>通过以上描述，将<code>AutoLayout</code>系统的作用描述如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/5835116-55978c66c8eea66b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FBB5F53F-0B23-48B2-B150-39B405BFB335.png"></p><h5 id="AutoLayout的性能"><a href="#AutoLayout的性能" class="headerlink" title="AutoLayout的性能"></a><code>AutoLayout</code>的性能</h5><p>从<code>AutoLayout</code>的原理，我们可以得出布局系统最后仍然需要通过<code>frame</code>来进行布局，相比原有的布局系统加入了从约束计算 出<code>frame</code> 的过程,那么这个过程对性能是否会影响呢？<br>你可以在 <a href="https://github.com/hua16/summary" target="_blank" rel="external"><strong>这里</strong></a> 找到这次对 <code>Layout</code> 性能测量使用的代码。<br>代码分别使用<code>Auto Layout</code>、嵌套视图层级中使用 <code>Auto Layout</code>和<code>frame</code>对 <code>N</code> 个视图进行布局，测算其运行时间。</p><p>对视图数量在 1~35 之间布局时间进行测量，结果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/117999-045780ced38306d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视图数量范围为 1~35.png"></p><p>对视图数量在 10~500 之间布局时间进行测量，结果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/117999-4a5f70dd55e894d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视图数量范围为 10~500.png"><br>从上述的测试数据可以看出，<strong>使用<code>frame</code>、<code>AutoLayout</code>和嵌套视图层级中使用 <code>Auto Layout</code>进行布局、对应的视图数量分别为<code>50</code>个、<code>6</code>个和<code>12</code>个，所需要的时间就会在 <code>16.67 ms</code>左右。</strong>,而想要让 iOS 应用的视图保持 60 FPS 的刷新频率，我们必须在 1/60 = 16.67 ms 之内完成包括布局、绘制以及渲染等操作。<br>综上所述，虽然说 <code>Auto Layout</code> 为开发者在多尺寸布局上提供了遍历，而且支持跨越视图层级的约束，但是由于其实现原理导致其时间复杂度为<strong>多项式时间</strong>，其性能损耗是仅使用 <code>frame</code> 的十几倍，所以在处理庞大的 <code>UI</code>界面时表现差强人意。 </p><h5 id="Masnory的使用"><a href="#Masnory的使用" class="headerlink" title="Masnory的使用"></a><code>Masnory</code>的使用</h5><p>下面，我们通过4个实例，来了解下<code>Masnory</code>的使用。</p><ul><li>######case 1: 并排显示两个<code>label</code>，宽度由内容决定。父视图宽度不够时，优先显示右边<code>label</code>的内容。</li></ul><p>在默认情况下，我们没有设置各个布局的优先级，那么他就会优先显示左边的<code>label</code>，左边的完全显示后剩余的空间都是右边的<code>label</code>，如果整个空间宽度都不够左边的<code>label</code>的话，那么右边的<code>label</code>就没有显示的机会了。<br>如果我们现在的需求是优先显示右边的<code>label</code>，左边的<code>label</code>内容超出的省略，这时就需要我们调整约束的优先级了。<br><code>UIView</code>中关于<code>Content Hugging</code> 和<code>Content Compression Resistance</code>的方法有：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UILayoutPriority</span>)contentHuggingPriorityForAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line">- (<span class="keyword">void</span>)setContentHuggingPriority:(<span class="built_in">UILayoutPriority</span>)priority forAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"></div><div class="line">- (<span class="built_in">UILayoutPriority</span>)contentCompressionResistancePriorityForAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line">- (<span class="keyword">void</span>)setContentCompressionResistancePriority:(<span class="built_in">UILayoutPriority</span>)priority forAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div></pre></td></tr></table></figure></p><p>那么这两个东西到底是什么呢？可以这样形象的理解一下：</p><ul><li><code>contentHugging</code>: 抱住使其在“内容大小”的基础上不能继续变大，这个属性的优先级越高，就要越“抱紧”视图里面的内容。也就是视图的大小不会随着父视图的扩大而扩大。</li><li><code>contentCompression</code>: 撑住使其在在其“内容大小”的基础上不能继续变小,这个属性的优先级越高，越不“容易”被压缩。也就是说，当整体的空间装不下所有的视图时，<code>Content Compression Resistance</code>优先级越高的，显示的内容越完整。<br>这两个属性分别可以设置水平方向和垂直方向上的，而且一个默认优先级是250， 一个默认优先级是750. 因为这两个很有可能与其他Constraint冲突，所以优先级较低。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityRequired</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) = <span class="number">1000</span>; <span class="comment">// A required constraint.  Do not exceed this.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityDefaultHigh</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) = <span class="number">750</span>; <span class="comment">// This is the priority level with which a button resists compressing its content.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityDefaultLow</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) = <span class="number">250</span>; <span class="comment">// This is the priority level at which a button hugs its contents horizontally.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityFittingSizeLevel</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) = <span class="number">50</span>;</div></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)layoutPageSubViews &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.leftLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.top.equalTo(<span class="keyword">self</span>.contentView1.mas_top).with.offset(<span class="number">5</span>);</div><div class="line">        make.left.equalTo(<span class="keyword">self</span>.contentView1.mas_left).with.offset(<span class="number">2</span>);</div><div class="line">        make.height.equalTo(@<span class="number">40</span>);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.rightLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.equalTo(<span class="keyword">self</span>.leftLabel.mas_right).with.offset(<span class="number">2</span>);</div><div class="line">        make.top.equalTo(<span class="keyword">self</span>.contentView1.mas_top).with.offset(<span class="number">5</span>);</div><div class="line">        make.right.lessThanOrEqualTo(<span class="keyword">self</span>.contentView1.mas_right).with.offset(<span class="number">-2</span>);</div><div class="line">        make.height.equalTo(@<span class="number">40</span>);</div><div class="line"></div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.leftLabel setContentHuggingPriority:<span class="built_in">UILayoutPriorityRequired</span></div><div class="line">                               forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</div><div class="line">    [<span class="keyword">self</span>.leftLabel setContentCompressionResistancePriority:<span class="built_in">UILayoutPriorityDefaultLow</span></div><div class="line">                                             forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.rightLabel setContentHuggingPriority:<span class="built_in">UILayoutPriorityRequired</span></div><div class="line">                               forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</div><div class="line">    [<span class="keyword">self</span>.rightLabel setContentCompressionResistancePriority:<span class="built_in">UILayoutPriorityRequired</span></div><div class="line">                                             forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>######case 2: 四个<code>ImageView</code>整体居中，可以任意显示、隐藏。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5835116-1334685bb89094f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="blog_autolayout_example_with_masonry_3.png"></p><p>下面的四个<code>Switch</code>控件分别控制上面对应位置的图片是否显示。</p><blockquote><p>分析:首先就是整体居中，为了实现这个，最简单的办法就是将四个图片“装进”一个<strong>容器View</strong>里面，然后让这个容器<code>View</code>在整个页面中居中即可。这样就不用控制每个图片的居中效果了。<br>然后就是显示与隐藏。在这里我直接控制图片<code>ImageView</code>的宽度，宽度为0的时候不就“隐藏”了吗。</p></blockquote><p>具体代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)layoutPageSubViews &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.height.mas_equalTo(IMAGE_SIZE);</div><div class="line">        make.centerX.equalTo(<span class="keyword">self</span>.view.mas_centerX);</div><div class="line">        make.top.equalTo(<span class="keyword">self</span>.view.mas_top).offset(<span class="number">200</span>);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">//分别设置每个imageView的宽高、左边、垂直中心约束，注意约束的对象</span></div><div class="line">    <span class="comment">//每个View的左边约束和左边的View的右边相等</span></div><div class="line">    __block <span class="built_in">UIView</span> *lastView = <span class="literal">nil</span>;</div><div class="line">    __block MASConstraint *widthConstraint = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSUInteger</span> arrayCount = <span class="keyword">self</span>.imageViews.count;</div><div class="line">    [<span class="keyword">self</span>.imageViews enumerateObjectsUsingBlock:^(<span class="built_in">UIView</span> *view, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">        [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">            make.left.equalTo(lastView ? lastView.mas_right : view.superview.mas_left);</div><div class="line">            make.centerY.equalTo(view.superview.mas_centerY);</div><div class="line">            <span class="keyword">if</span> (idx == arrayCount - <span class="number">1</span>) &#123;</div><div class="line">                make.right.equalTo(view.superview.mas_right);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            widthConstraint = make.width.mas_equalTo(IMAGE_SIZE);</div><div class="line">            make.height.mas_equalTo(IMAGE_SIZE);</div><div class="line">            </div><div class="line">            [<span class="keyword">self</span>.widthConstraints addObject:widthConstraint];</div><div class="line">            lastView = view;</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - event response</span></div><div class="line"><span class="comment">//点击switch按钮，如果打开，对应视图的宽约束设置为32，否则，设置为0</span></div><div class="line">- (<span class="keyword">IBAction</span>)showOrHideImage:(<span class="built_in">UISwitch</span> *)sender &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> index = (<span class="built_in">NSUInteger</span>) sender.tag;</div><div class="line">    MASConstraint *width = <span class="keyword">self</span>.widthConstraints[index];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sender.on) &#123;</div><div class="line">        width.mas_equalTo(IMAGE_SIZE);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        width.mas_equalTo(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>#####case 3: 子视图的宽度始终是父视图的四分之三（或者任意百分比）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  <span class="comment">//宽度为父view的宽度的四分之三 </span></div><div class="line">[subView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        <span class="comment">//上下左贴边</span></div><div class="line">        make.left.equalTo(_containerView.mas_left);</div><div class="line">        make.top.equalTo(_containerView.mas_top);</div><div class="line">        make.bottom.equalTo(_containerView.mas_bottom);</div><div class="line">        <span class="comment">//宽度为父view的宽度的一半</span></div><div class="line">        make.width.equalTo(_containerView.mas_width).multipliedBy(<span class="number">0.75</span>);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure></li><li><p>#####case 4 给同一个属性添加多重约束，实现复杂关系</p></li></ul><pre><code class="objc">- (<span class="keyword">void</span>)layoutPageSubviews {    [<span class="keyword">self</span>.greenLabel mas_makeConstraints:^(MASConstraintMaker *make) {        make.centerY.equalTo(<span class="keyword">self</span>.containerView);        make.right.lessThanOrEqualTo(<span class="keyword">self</span>.containerView);        make.left.greaterThanOrEqualTo(<span class="keyword">self</span>.containerView.mas_right).multipliedBy((<span class="built_in">CGFloat</span>)(<span class="number">1.0</span>f / <span class="number">3.0</span>f));        <span class="keyword">for</span> (<span class="built_in">UILabel</span> *label <span class="keyword">in</span> <span class="keyword">self</span>.leftLabels) {            make.left.greaterThanOrEqualTo(label.mas_right).offset(<span class="number">8</span>);        }    }];    [<span class="keyword">self</span>.greenLabel setContentCompressionResistancePriority:<span class="built_in">UILayoutPriorityRequired</span> forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];}</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过上述分析，我们可以发现：</p><ul><li><code>AutoLayout</code>的原理就是对线性方程组或者不等式的求解，最终使用<code>frame</code>来绘制视图；</li><li>使用<code>AutoLayout</code>进行布局时， 由于其实现原理导致其时间复杂度为多项式时间，其性能损耗是仅使用 frame 的十几倍，所以在处理庞大的 UI界面时表现差强人意。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;&lt;code&gt;UI&lt;/code&gt;布局对于&lt;code&gt;iOS&lt;/code&gt;开发者来说并不陌生，在&lt;code&gt;iOS6&lt;/code&gt;之前，大家都是
      
    
    </summary>
    
      <category term="iOS 自动布局" scheme="http://www.leverTsui.com/categories/iOS-%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="自动布局 AutoLayout Masnory" scheme="http://www.leverTsui.com/tags/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80-AutoLayout-Masnory/"/>
    
  </entry>
  
  <entry>
    <title>iOS二维码识别/二维码生成</title>
    <link href="http://www.leverTsui.com/2017/11/03/qr-droid/"/>
    <id>http://www.leverTsui.com/2017/11/03/qr-droid/</id>
    <published>2017-11-03T12:42:00.000Z</published>
    <updated>2017-11-06T09:06:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前做过一个关于二维码的组件，已发布，现总结下。<br>开发的<code>APP</code>所需支持的最低版本为<code>8.0</code>，最初的方案为扫描使用苹果自带的<code>API</code>实现扫一扫的功能、使用<code>ZXing</code>识别从相册或别人转发的二维码图片。但发现<code>ZXing</code>识别从相册中来的图片性能很差，很多图片识别不了，且耗时较长，遂使用<code>ZBar</code>来实现识别从相册或别人转发的二维码图片。<br>这个组件重要实现了三个功能，扫一扫识别二维码图片、长按图片识别二维码图片和生成二维码图片。<br>首先来看下扫一扫识别二维码图片的代码实现：</p><h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><h5 id="扫一扫识别二维码图片"><a href="#扫一扫识别二维码图片" class="headerlink" title="扫一扫识别二维码图片"></a>扫一扫识别二维码图片</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)initCapture &#123;</div><div class="line">    <span class="built_in">AVCaptureDevice</span>* inputDevice =</div><div class="line">    [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>]; </div><div class="line">    [inputDevice lockForConfiguration:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">if</span> ([inputDevice hasTorch])&#123;</div><div class="line">        inputDevice.torchMode = <span class="built_in">AVCaptureTorchModeAuto</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">AVCaptureFocusMode</span> foucusMode = <span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>;</div><div class="line">    <span class="keyword">if</span> ([inputDevice isFocusModeSupported:foucusMode]) &#123;</div><div class="line">        inputDevice.focusMode = foucusMode;</div><div class="line">    &#125;</div><div class="line">    [inputDevice unlockForConfiguration];</div><div class="line">    </div><div class="line">    <span class="built_in">AVCaptureDeviceInput</span> *captureInput =</div><div class="line">    [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:inputDevice error:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!captureInput) &#123;</div><div class="line">        <span class="comment">//支持的最低版本为iOS8</span></div><div class="line">        <span class="built_in">UIAlertController</span> *alterVC = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:MUIQRCodeLocalizedString(<span class="string">@"ScanViewController_system_tip"</span>) message:MUIQRCodeLocalizedString(<span class="string">@"ScanViewController_camera_permission"</span>) preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</div><div class="line">        <span class="built_in">UIAlertAction</span> *confirmAction = [<span class="built_in">UIAlertAction</span> actionWithTitle:MUIQRCodeLocalizedString(<span class="string">@"ScanViewController_yes"</span>) style:<span class="built_in">UIAlertActionStyleDefault</span> handler:<span class="literal">nil</span>];</div><div class="line">        [alterVC addAction:confirmAction];</div><div class="line">        [<span class="keyword">self</span> presentViewController:alterVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">        [<span class="keyword">self</span>.activityView stopAnimating];</div><div class="line">        [<span class="keyword">self</span> onVideoStart:<span class="literal">nil</span>];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">AVCaptureMetadataOutput</span> *captureOutput = [[<span class="built_in">AVCaptureMetadataOutput</span> alloc] init];</div><div class="line">    [captureOutput setMetadataObjectsDelegate:<span class="keyword">self</span> queue:_queue];</div><div class="line">    <span class="keyword">self</span>.captureOutput = captureOutput;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.captureSession = [[<span class="built_in">AVCaptureSession</span> alloc] init];</div><div class="line">    [<span class="keyword">self</span>.captureSession addInput:captureInput];</div><div class="line">    [<span class="keyword">self</span>.captureSession addOutput:captureOutput];</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> w = <span class="number">1920.</span>f;</div><div class="line">    <span class="built_in">CGFloat</span> h = <span class="number">1080.</span>f;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset1920x1080</span>]) &#123;</div><div class="line">        <span class="keyword">self</span>.captureSession.sessionPreset = <span class="built_in">AVCaptureSessionPreset1920x1080</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset1280x720</span>]) &#123;</div><div class="line">        <span class="keyword">self</span>.captureSession.sessionPreset = <span class="built_in">AVCaptureSessionPreset1280x720</span>;</div><div class="line">        w = <span class="number">1280.</span>f;</div><div class="line">        h = <span class="number">720.</span>f;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>]) &#123;</div><div class="line">        <span class="keyword">self</span>.captureSession.sessionPreset = <span class="built_in">AVCaptureSessionPreset640x480</span>;</div><div class="line">        w = <span class="number">960.</span>f;</div><div class="line">        h = <span class="number">540.</span>f;</div><div class="line">    &#125;</div><div class="line">    captureOutput.metadataObjectTypes = [captureOutput availableMetadataObjectTypes];</div><div class="line">    <span class="built_in">CGRect</span> bounds = [[<span class="built_in">UIScreen</span> mainScreen] bounds];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.prevLayer) &#123;</div><div class="line">        <span class="keyword">self</span>.prevLayer = [<span class="built_in">AVCaptureVideoPreviewLayer</span> layerWithSession:<span class="keyword">self</span>.captureSession];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.prevLayer.frame = bounds;</div><div class="line">    <span class="keyword">self</span>.prevLayer.videoGravity = <span class="built_in">AVLayerVideoGravityResizeAspectFill</span>;</div><div class="line">    [<span class="keyword">self</span>.view.layer insertSublayer:<span class="keyword">self</span>.prevLayer atIndex:<span class="number">0</span>];</div><div class="line">    <span class="comment">//下面代码主要用来设置扫描的聚焦范围，计算rectOfInterest</span></div><div class="line">    <span class="built_in">CGFloat</span> p1 = bounds.size.height/bounds.size.width;</div><div class="line">    <span class="built_in">CGFloat</span> p2 = w/h;</div><div class="line">    </div><div class="line">    <span class="built_in">CGRect</span> cropRect = <span class="built_in">CGRectMake</span>(<span class="built_in">CGRectGetMinX</span>(_cropRect) - kSNReaderScanExpandWidth, <span class="built_in">CGRectGetMinY</span>(_cropRect) - kSNReaderScanExpandHeight, <span class="built_in">CGRectGetWidth</span>(_cropRect) + <span class="number">2</span>*kSNReaderScanExpandWidth, <span class="built_in">CGRectGetHeight</span>(_cropRect) + <span class="number">2</span>*kSNReaderScanExpandHeight);</div><div class="line">    </div><div class="line"><span class="comment">//    CGRect cropRect = _cropRect;</span></div><div class="line">    <span class="keyword">if</span> (fabs(p1 - p2) &lt; <span class="number">0.00001</span>) &#123;</div><div class="line">        captureOutput.rectOfInterest = <span class="built_in">CGRectMake</span>(cropRect.origin.y /bounds.size.height,                         cropRect.origin.x/bounds.size.width,</div><div class="line">                                                  cropRect.size.height/bounds.size.height,</div><div class="line">                                                  cropRect.size.width/bounds.size.width);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 &lt; p2) &#123;</div><div class="line">        <span class="comment">//实际图像被截取一段高</span></div><div class="line">        <span class="built_in">CGFloat</span> fixHeight = bounds.size.width * w / h;</div><div class="line">        <span class="built_in">CGFloat</span> fixPadding = (fixHeight - bounds.size.height)/<span class="number">2</span>;</div><div class="line">        captureOutput.rectOfInterest = <span class="built_in">CGRectMake</span>((cropRect.origin.y + fixPadding)/fixHeight,</div><div class="line">                                                  cropRect.origin.x/bounds.size.width,</div><div class="line">                                                  cropRect.size.height/fixHeight,</div><div class="line">                                                  cropRect.size.width/bounds.size.width);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">CGFloat</span> fixWidth = bounds.size.height * h / w;</div><div class="line">        <span class="built_in">CGFloat</span> fixPadding = (fixWidth - bounds.size.width)/<span class="number">2</span>;</div><div class="line">        captureOutput.rectOfInterest = <span class="built_in">CGRectMake</span>(cropRect.origin.y/bounds.size.height,</div><div class="line">                                                  (cropRect.origin.x + fixPadding)/fixWidth,</div><div class="line">                                                  cropRect.size.height/bounds.size.height,</div><div class="line">                                                  cropRect.size.width/fixWidth);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="识别二维码图片"><a href="#识别二维码图片" class="headerlink" title="识别二维码图片"></a>识别二维码图片</h5><p>识别二维码图片的功能，最初的方案是使用三方库<code>ZXing</code>来实现，因为<code>ZXing</code>有人在维护，但<code>ZXing</code>识别相册中的二维码图片或本地的图片时，有些图片根本就识别不出来，且耗时较长，所以改为使用<code>ZBar</code>。在网上找到一篇文章<a href="http://adad184.com/2015/09/30/goodbye-zxing/" target="_blank" rel="external">再见ZXing 使用系统原生代码处理QRCode</a>,实测发现使用系统原生代码来识别二维码图片时，在，iphone4s，系统为iOS9的手机发现传回来的数组为空。代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)decodeQRImageWith:(<span class="built_in">UIImage</span>*)aImage &#123;</div><div class="line">    <span class="built_in">NSString</span> *qrResult = <span class="literal">nil</span>; </div><div class="line">    <span class="comment">//iOS8及以上可以使用系统自带的识别二维码图片接口，但此api有问题，在一些机型上detector为nil。 </span></div><div class="line">    <span class="keyword">if</span> (iOS8_OR_LATER) &#123; </div><div class="line">          <span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</div><div class="line">          <span class="built_in">CIDetector</span> *detector = [<span class="built_in">CIDetector</span> detectorOfType:<span class="built_in">CIDetectorTypeQRCode</span> context:context options:@&#123;<span class="built_in">CIDetectorAccuracy</span>:<span class="built_in">CIDetectorAccuracyHigh</span>&#125;];</div><div class="line">          <span class="built_in">CIImage</span> *image = [<span class="built_in">CIImage</span> imageWithCGImage:aImage.CGImage];</div><div class="line">          <span class="built_in">NSArray</span> *features = [detector featuresInImage:image];</div><div class="line">          <span class="built_in">CIQRCodeFeature</span> *feature = [features firstObject]; </div><div class="line">          qrResult = feature.messageString;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          ZBarReaderController* read = [ZBarReaderController new];</div><div class="line">          <span class="built_in">CGImageRef</span> cgImageRef = aImage.CGImage;</div><div class="line">          ZBarSymbol* symbol = <span class="literal">nil</span>;</div><div class="line">          <span class="keyword">for</span>(symbol <span class="keyword">in</span> [read scanImage:cgImageRef]) <span class="keyword">break</span>;</div><div class="line">             qrResult = symbol.data ;</div><div class="line">            <span class="keyword">return</span> qrResult;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>无图无真相：</p><p><img src="http://upload-images.jianshu.io/upload_images/117999-5dae9fc15755140c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14567CBE-E1D2-4FA7-AFA3-8B2037171F38.jpg"> </p><p>detector的值为nil，也就是说 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CIDetector</span> *detector = [<span class="built_in">CIDetector</span> detectorOfType:<span class="built_in">CIDetectorTypeQRCode</span> context:context options:@&#123;<span class="built_in">CIDetectorAccuracy</span>:<span class="built_in">CIDetectorAccuracyHigh</span>&#125;];</div></pre></td></tr></table></figure><p>CIDetector的初始化方法无效。推测是苹果API的问题。 </p><h5 id="生成二维码图片"><a href="#生成二维码图片" class="headerlink" title="生成二维码图片"></a>生成二维码图片</h5><p>在<code>iOS8</code>及以上版本使用苹果的<code>API</code>生成二维码图片，代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)encodeQRImageWithContent:(<span class="built_in">NSString</span> *)content size:(<span class="built_in">CGSize</span>)size &#123;</div><div class="line">    <span class="built_in">UIImage</span> *codeImage = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (iOS8_OR_LATER) &#123;</div><div class="line">        <span class="built_in">NSData</span> *stringData = [content dataUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span>]; </div><div class="line">        <span class="comment">//生成</span></div><div class="line">      <span class="built_in">CIFilter</span> *qrFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIQRCodeGenerator"</span>];</div><div class="line">      [qrFilter setValue:stringData forKey:<span class="string">@"inputMessage"</span>];</div><div class="line">      [qrFilter setValue:<span class="string">@"M"</span> forKey:<span class="string">@"inputCorrectionLevel"</span>];</div><div class="line">      <span class="built_in">UIColor</span> *onColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">      <span class="built_in">UIColor</span> *offColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">      <span class="comment">//上色</span></div><div class="line">      <span class="built_in">CIFilter</span> *colorFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIFalseColor"</span></div><div class="line">                                         keysAndValues:</div><div class="line">                               <span class="string">@"inputImage"</span>,qrFilter.outputImage,</div><div class="line">                               <span class="string">@"inputColor0"</span>,[<span class="built_in">CIColor</span> colorWithCGColor:onColor.CGColor],</div><div class="line">                               <span class="string">@"inputColor1"</span>,[<span class="built_in">CIColor</span> colorWithCGColor:offColor.CGColor],</div><div class="line">                               <span class="literal">nil</span>];</div><div class="line"></div><div class="line">      <span class="built_in">CIImage</span> *qrImage = colorFilter.outputImage;</div><div class="line">      <span class="built_in">CGImageRef</span> cgImage = [[<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>] createCGImage:qrImage fromRect:qrImage.extent];</div><div class="line">      <span class="built_in">UIGraphicsBeginImageContext</span>(size);</div><div class="line">      <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">      <span class="built_in">CGContextSetInterpolationQuality</span>(context, kCGInterpolationNone);</div><div class="line">      <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, <span class="number">-1.0</span>);</div><div class="line">      <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGContextGetClipBoundingBox</span>(context), cgImage);</div><div class="line">      codeImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">      <span class="built_in">UIGraphicsEndImageContext</span>(); </div><div class="line">      <span class="built_in">CGImageRelease</span>(cgImage);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          codeImage = [QRCodeGenerator qrImageForString:content imageSize:size.width];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> codeImage;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p><code>iOS8</code>以下使用<code>libqrencode</code>库来生成二维码图片。</p><h4 id="代码完善"><a href="#代码完善" class="headerlink" title="代码完善"></a>代码完善</h4><p><code>2015年12月11日</code> </p><p><code>QA</code>测试发现，服务端生成的二维码，使用<code>ZBar</code>识别不出来，但将这张图片保存到相册，然后发送就可以识别出来。最初的想法是要服务端修改生成的二维码，但安卓能够识别出来，此路不通，那只有看ZBar的源码了。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">NSFastEnumeration</span>&gt;) scanImage: (<span class="built_in">CGImageRef</span>) image &#123;</div><div class="line">        timer_start;</div><div class="line">        <span class="keyword">int</span> nsyms = [<span class="keyword">self</span> scanImage: image</div><div class="line">                          withScaling: <span class="number">0</span>];</div><div class="line">      <span class="comment">//没有识别出来，判断CGImageRef对象的宽和高是否大于640，大于或等于的话进行缩放再进行扫描</span></div><div class="line">        <span class="keyword">if</span>(!nsyms &amp;&amp;</div><div class="line">           <span class="built_in">CGImageGetWidth</span>(image) &gt;= <span class="number">640</span> &amp;&amp;</div><div class="line">           <span class="built_in">CGImageGetHeight</span>(image) &gt;= <span class="number">640</span>)</div><div class="line">            <span class="comment">// make one more attempt for close up, grainy images</span></div><div class="line">            nsyms = [<span class="keyword">self</span> scanImage: image</div><div class="line">                          withScaling: <span class="number">.5</span>];</div><div class="line"></div><div class="line">        <span class="built_in">NSMutableArray</span> *syms = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">if</span>(nsyms) &#123;</div><div class="line">            <span class="comment">// quality/type filtering</span></div><div class="line">            <span class="keyword">int</span> max_quality = MIN_QUALITY;</div><div class="line">            <span class="keyword">for</span>(ZBarSymbol *sym <span class="keyword">in</span> scanner.results) &#123;</div><div class="line">                zbar_symbol_type_t type = sym.type;</div><div class="line">                <span class="keyword">int</span> quality;</div><div class="line">                <span class="keyword">if</span>(type == ZBAR_QRCODE)</div><div class="line">                    quality = INT_MAX;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    quality = sym.quality;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(quality &lt; max_quality) &#123;</div><div class="line">                    zlog(<span class="string">@"    type=%d quality=%d &lt; %d\n"</span>,</div><div class="line">                         type, quality, max_quality);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(max_quality &lt; quality) &#123;</div><div class="line">                    max_quality = quality;</div><div class="line">                    <span class="keyword">if</span>(syms)</div><div class="line">                        [syms removeAllObjects];</div><div class="line">                &#125;</div><div class="line">                zlog(<span class="string">@"    type=%d quality=%d\n"</span>, type, quality);</div><div class="line">                <span class="keyword">if</span>(!syms)</div><div class="line">                    syms = [<span class="built_in">NSMutableArray</span> arrayWithCapacity: <span class="number">1</span>];</div><div class="line"></div><div class="line">                [syms addObject: sym];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        zlog(<span class="string">@"read %d filtered symbols in %gs total\n"</span>,</div><div class="line">              (!syms) ? <span class="number">0</span> : [syms count], timer_elapsed(t_start, timer_now()));</div><div class="line">        <span class="keyword">return</span>(syms);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(max_quality &lt; quality) &#123;</div><div class="line">          max_quality = quality;</div><div class="line">          <span class="keyword">if</span>(syms)</div><div class="line">              [syms removeAllObjects];</div><div class="line">      &#125;</div><div class="line">      zlog(<span class="string">@"    type=%d quality=%d\n"</span>, type, quality);</div><div class="line">      <span class="keyword">if</span>(!syms)</div><div class="line">          syms = [<span class="built_in">NSMutableArray</span> arrayWithCapacity: <span class="number">1</span>];</div><div class="line"></div><div class="line">      [syms addObject: sym];</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  zlog(<span class="string">@"read %d filtered symbols in %gs total\n"</span>,</div><div class="line">        (!syms) ? <span class="number">0</span> : [syms count], timer_elapsed(t_start, timer_now()));</div><div class="line">  <span class="keyword">return</span>(syms);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里就产生了一个解决有些二维码图片识别不出来的解决思路：将传过来的<code>UIImage</code>的宽和高设置为640，识别不出来再进行缩放识别。修改<code>UIImage</code>的代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UIImage</span> *)TransformtoSize:(<span class="built_in">CGSize</span>)Newsize &#123;</div><div class="line">    <span class="comment">// 创建一个bitmap的context</span></div><div class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(Newsize);</div><div class="line">    <span class="comment">// 绘制改变大小的图片</span></div><div class="line">    [<span class="keyword">self</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, Newsize.width, Newsize.height)];</div><div class="line">    <span class="comment">// 从当前context中创建一个改变大小后的图片</span></div><div class="line">    <span class="built_in">UIImage</span> *TransformedImg=<span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    <span class="comment">// 使当前的context出堆栈</span></div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    <span class="comment">// 返回新的改变大小后的图片</span></div><div class="line">    <span class="keyword">return</span> TransformedImg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样类似于将<code>ZXing</code>中的<code>tryHard</code>设置为<code>YES</code>。识别不出来的二维码图片就可以识别了。</p><p><code>2016年5月20日</code><br><code>遗留的bug</code>: 点击进入扫一扫界面，退出，再进入，这样重复5次左右，扫一扫之前的界面的会出现卡顿。<br>原因：多次进入扫一扫界面，再退出，因此界面未被系统回收，captureSession对象一直在运行，会造成内存泄露，引起上一个界面卡顿。<br>解决方案：在视图将要消失的时候，确保captureSession对象停止运行。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">  [<span class="keyword">super</span> viewWillDisappear:animated];</div><div class="line">  <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession isRunning]) &#123;</div><div class="line">      [<span class="keyword">self</span>.captureSession stopRunning];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>源码和demo请点<a href="https://github.com/hua16/QRCodeDemo.git" target="_blank" rel="external">这里</a><br>参考的文章链接如下<br><a href="http://adad184.com/2015/09/30/goodbye-zxing/" target="_blank" rel="external">再见ZXing 使用系统原生代码处理QRCode</a><br><a href="http://blog.cnbluebox.com/blog/2014/08/26/ioser-wei-ma-sao-miao/" target="_blank" rel="external">IOS二维码扫描,你需要注意的两件事</a><br><a href="http://blog.csdn.net/u013738531/article/details/54574262" target="_blank" rel="external"><a href="http://blog.csdn.net/u013738531/article/details/54574262" target="_blank" rel="external">Zbar算法流程介绍</a></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;之前做过一个关于二维码的组件，已发布，现总结下。&lt;br&gt;开发的&lt;code&gt;APP&lt;/code&gt;所需支持的最低版本为&lt;code&gt;8.0&lt;/co
      
    
    </summary>
    
      <category term="iOS 开发" scheme="http://www.leverTsui.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="二维码 图片识别" scheme="http://www.leverTsui.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
</feed>
